package integerToRoman;
// 由于linkedhashmap 速度比较慢，而且这一题不需要多次使用，可以从最大的开始进行递减 用/ 和 % 结合。
// 只有10 的整数倍才有可能有很多个，其余的都只有一个，如果比他要大，就直接append 然后减掉就可以了。
public class UseWhile {
	public static String intToRoman(int num) {
		StringBuffer result = new StringBuffer();
		if (num >= 1000) {
			result.append(repeat(num, 1000, "M"));
			num %= 1000;
		}
		if (num >= 900) {
			result.append("CM");
			num -= 900;
		}
		if (num >= 500) {
			result.append("D");
			num -= 500;
		}
		if (num >= 400) {
			result.append("CD");
			num -= 400;
		}

		if (num >= 100) {
			result.append(repeat(num, 100, "C"));
			num %= 100;
		}
		
		if (num >= 90) {
			result.append("XC");
			num -= 90;
		}
		
		if (num >= 50) {
			result.append("L");
			num -= 50;
		}
		
		if (num >= 40) {
			result.append("XL");
			num -= 40;
		}
		
		if (num >= 10) {
			result.append(repeat(num, 10, "X"));
			num %= 10;
		}
		
		if (num >= 9) {
			result.append("IX");
			num -= 9;
		}
		if (num >= 5) {
			result.append("V");
			num -= 5;
		}
		if (num >= 4) {
			result.append("IV");
			num -= 4;
		}
		if (num >= 1) {
			result.append(repeat(num, 1, "I"));
			num %= 1;
		}
		
		return result.toString();

	}

	public static String repeat(int num, int fac, String unit) {
		StringBuffer s = new StringBuffer();
		for (int i = 0; i < num / fac; i++) {
			s.append(unit);
		}
		return s.toString();
	}
	
	public static void main(String[] args) {
		int input = 3999;
		System.out.println(intToRoman(input));
		System.out.println(new UseLinkedHashMap().intToRoman(input));
		System.out.println(intToRoman(input).equals((new UseLinkedHashMap().intToRoman(input))));
	}
}
