package wordBreakII;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
// 完全用递归做太慢，考虑用DP 来进行
// 首先定义DP的每一维的物理含义。 这里用了一个二维数组，第一维表示开始index 的位置，第二维表示字符串的长度，所以二维数组的有len 长， len+1宽
// 因为DP是在前一个基础之上进行，所以外层循环用的是len 的长度，从1 到总的len
// 内层循环用的是开始的index 但是要进行保证他和上面的加起来不能超过总的len ，这样能够全部覆盖起来。
// 具体到里面来说，如果这个start 开始的len 长度的string 存在于dict 当中就说明这个是true
// 如果不存在开始进行切割，看看左右两边是不是都是可以由dict 里面的词组成。因为是从长度1开始的，所以肯定 能够保证我要判断长的时候，短的已经判断完成。
// 这样避免了重复运算。 最后看的是从0开始有len 长的字符串是不是可以由子字符串组成。 如果不行就直接返回空的。
// 如果可以再进行判断是由哪些来进行组成。
// 因为要将一个完整的组成部分输出出来所以用的是DFS
// base case 是我start到了最后一位也就是len 的长度，这时候就可以将buffer 里面存的 东西输入到arraylist 里面去，因为每次存的时候加入了 “ ”
// 这个时候就要去buffer 里面的倒数第二位的，用到了substring
// 
public class DP {
	public static ArrayList<String> wordBreak(String s, Set<String> dict) {
		ArrayList<String> result = new ArrayList<String>();
		if (s == null || s.isEmpty()) {
			return result;
		}

		boolean[][] dp = new boolean[s.length()][s.length() + 1];
		for (int len = 1; len <= s.length(); len++) {
			for (int start = 0; start <= s.length() - len; start++) {
				int end = start + len;
				String subString = s.substring(start, end);
				if (dict.contains(subString)) {
					dp[start][len] = true;
				} else {
					for (int m = 1; m < len; m++) {
						if (dp[start][m] && dp[start + m][len - m]) {
							dp[start][len] = true;
							break;
						}
					}
				}
			}
		}

		if (!dp[0][s.length()]) {
			return result;
		} else {
			StringBuffer sb = new StringBuffer();
			wordBreakHelper(0, s, dict, dp, result, sb);
			return result;
		}
	}

	private static void wordBreakHelper(int start, String s, Set<String> dict,
			boolean[][] dp, ArrayList<String> result, StringBuffer sb) {
		int len = s.length();
		if (start == len) {
			result.add(sb.substring(0, sb.length() - 1));
			return;
		}

		for (int l = 1; l <= len - start; l++) {
			//if (dp[start][l]) {
				String left = s.substring(start, start + l);
				if (dict.contains(left)) {
					int lastPos = sb.length();
					sb.append(left + " ");
					wordBreakHelper(start + l, s, dict, dp, result, sb);
					sb.delete(lastPos, sb.length());
				}
			//}
		}
	}

	public static void main(String[] args) {
//		String s = "catsanddog";
//		Set<String> dict = new HashSet<>();
//		dict.add("cat");
//		dict.add("cats");
//		dict.add("and");
//		dict.add("sand");
//		dict.add("dog");
//		System.out.println(wordBreak(s, dict));
		
		String s = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaav";
		Set<String> dict = new HashSet<>();
		dict.add("a");
		dict.add("aa");
		dict.add("aaa");
		dict.add("aaaa");
		dict.add("aaaaa");
		dict.add("aaaaaa");
		dict.add("aaaaaaa");
		dict.add("aaaaaaaa");
		dict.add("aaaaaaaaa");
		dict.add("aaaaaaaaaa");

		System.out.println(wordBreak(s, dict));
	}

}
