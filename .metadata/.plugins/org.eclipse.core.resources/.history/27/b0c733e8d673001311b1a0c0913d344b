package insertionSortList;
// 首先要了解insertion sort 是怎么运行的工作原理，是将一个无序的数组或者list ，从第二个开始，或者是从第一个开始，看怎么在前面的list 插进去，
// 因为前面是已经排好序的，所以插在合适的位置，那么插完之后的也是一个sorted 的顺序。
// 因为这个是list 所以是可以直接插的，所以只需要从头开始找，第一个比他大的，那么就插在他的前面。但是单链表，不能往前插，所以node 要提前预判，所以一直用的是这个的next 来进行比较
// 这样一直是第一个比他大的node 的前面一个。
// 如果next 的val 一直到了现在这个，说明已经是排好序的，所以就直接到下面一个。而每次都是从第一个的前面一个开始，所以用了一个dummy 来表示，
public class InsertSort {
	public static ListNode insertionSortList(ListNode head) {
		if (head == null || head.next == null) {
			return head;
		}

		ListNode dummy = new ListNode(0);
		dummy.next = head;

		ListNode next = head.next;

		while (next != null) {

			ListNode prev = dummy;

			while (prev.next != next && prev.next.val <= next.val) {
				prev = prev.next;
			}

			if (prev.next == next) {
				next = next.next;
			} else {
				ListNode cur = prev.next;
				ListNode nNext = next.next;
				prev.next = next;
				next.next = cur;

				while (cur.next != next) {
					cur = cur.next;
				}
				cur.next = nNext;
				next = nNext;
			}
		}
		return dummy.next;
	}

	public static void printList(ListNode head) {
		while (head != null) {
			System.out.print(head.val + "=>");
			head = head.next;
		}

		System.out.println("NULL");
	}

	public static void main(String[] args) {
		ListNode l1 = new ListNode(2);
		ListNode l2 = new ListNode(1);
		ListNode l3 = new ListNode(3);
		ListNode l4 = new ListNode(4);
		ListNode l5 = new ListNode(3);
		ListNode l6 = new ListNode(2);
		ListNode l7 = new ListNode(5);
		ListNode l8 = new ListNode(6);

		l1.next = l2;
		l2.next = l3;
		l3.next = l4;
		l4.next = l5;
		l5.next = l6;
		l6.next = l7;
		l7.next = l8;

		ListNode head = insertionSortList(l1);
		printList(head);

	}
}
