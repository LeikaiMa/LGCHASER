package mergeKSortedLists;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.PriorityQueue;
// 这里用的heapsort 将元素塞进一个heap 当中，然后从heap 中取顶上的值，就是目前为止最小的。
// 因为是sort 过的，所以就不用全部塞进去，而是一个一个塞，这样也会省掉排序的时间。
public class HeapSort {
	public ListNode mergeKLists(ArrayList<ListNode> lists) {
		if (lists.size() == 0) {
			return null;
		}

		Comparator<ListNode> comparator = new Comparator<ListNode>() {

			@Override
			public int compare(ListNode n1, ListNode n2) {
				if (n1.val < n2.val) {
					return -1;
				}
				if (n1.val > n2.val) {
					return 1;
				}
				return 0;

			}
		};

		PriorityQueue<ListNode> heap = new PriorityQueue<ListNode>(lists.size(), comparator);

		for (ListNode node : lists) {
			if (node != null) {
				heap.add(node);
			}
		}

		ListNode head = null, cur = null;
		while (!heap.isEmpty()) {
			if (head == null) {
				head = heap.poll();
				cur = head;
			} else {
				cur.next = heap.poll();
				cur = cur.next;
			}
			if (cur.next != null) {
				heap.add(cur.next);
			}
		}

		return head;
	}

}
