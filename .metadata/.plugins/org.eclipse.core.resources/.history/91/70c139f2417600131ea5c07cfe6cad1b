package provideLockNoDeadLock;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.concurrent.locks.Lock;

// remove element 是直接将这个元素出现的第一次删除。
public class LockNode {
	public enum VisitState {
		FRESH, VISITING, VISITED
	};

	private ArrayList<LockNode> children;

	private int lockId;
	private Lock lock;
	private int maxLocks;

	public LockNode(int id, int max) {
		lockId = id;
		maxLocks = max;
	}

	public void JoinTo(LockNode node) {
		children.add(node);
	}

	public void remove(LockNode node) {
		children.remove(node);
	}

	public boolean hasCycle(HashMap<Integer, Boolean> touchedNodes) {
		VisitState[] visited = new VisitState[maxLocks];
		for (int i = 0; i < maxLocks; i++) {
			visited[i] = VisitState.FRESH;
		}
		return hasCycle(visited, touchedNodes);
	}

	public boolean hasCycle(VisitState[] visited,
			HashMap<Integer, Boolean> touchedNodes) {
		if (touchedNodes.containsKey(lockId)) {
			touchedNodes.put(lockId, true);
		}

		if (visited[lockId] == VisitState.VISITING) {
			return true;
		} else if (visited[lockId] == VisitState.FRESH) {
			visited[lockId] = VisitState.VISITING;
			for (LockNode n : children) {
				if (n.hasCycle(visited, touchedNodes)) {
					return true;
				}
			}
		}

	}

}
