package distinctSubsequences;
//运用DP 的方法一步一步添加，先在开头的地方加上两个空的字符，作为递归的条件，他们肯定是相等的，所以在最开始的一个填的是1， 
//然后横着的一行，因为肯定都和空的字符不同，所以都是删除的动作，所以和前面的相同，也就是1
//竖着的第一列，因为肯定和空的字符不同，所以是0.
//然后每一行进行一次填充，因为整个的dp的横着的表示要进行比较的，竖着的是标准的，也就是横着的要比竖着的长。
//所以只有两种可能一种是删除一种是保留。如果是相同的值说明是可以保留替换的，如果不同就是要标明删除的，所以就是有两种途径。
//一种删除就是和左边的个数是相同的，一种是替换这就标明的是从左斜上依次过来的，所以他的次数和左斜上方的次数是相同的。这也是为什么开头要加空字符的原因。
//为了最开始的时候有个base case
//一次到最右下角的一个就是标明完全比较完了之后最后的结果。
//一种小优化是左下角的大部分都是0 没有用到。可以省略计算。但下面没有进行类似的优化。


//左边是要进行比较的，上面是长的，那么就有两种情况，两个都+1 类似于替换的效果，还有一个一种就是删除，一个一个进行比较
//至少一种情况是删除，所以每个人的基本情况就是[j-1] 记住是[j-1] 而不是[i-1]，应该是一行的，如果相同的还有一种情况是就是直接替换掉还要加上左上角的
//开始的时候就是第一行和空的比，全部删除都是可以的，所以都是1 而没有插入这个功能，所以 竖着的第一列都是0
public class ReplaceAndDEletion {
	public int numDistinct(String S, String T) {
		if (S == null || T == null) {
			return 0;
		}

		if (S.length() < T.length()) {
			return 0;
		}

		int[][] dp = new int[T.length() + 1][S.length() + 1];

		for (int j = 0; j < S.length() + 1; j++) {
			dp[0][j] = 1;
		}

		for (int i = 1; i < T.length() + 1; i++) {
			dp[i][0] = 0;
		}

		for (int i = 1; i < T.length() + 1; i++) {
			for (int j = 1; j < S.length() + 1; j++) {
				if (S.charAt(j - 1) == T.charAt(i - 1)) {
					dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];
				} else {
					dp[i][j] = dp[i][j - 1];
				}
			}
		}

		return dp[T.length()][S.length()];
	}
}
