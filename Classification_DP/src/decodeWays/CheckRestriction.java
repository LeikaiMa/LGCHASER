package decodeWays;
// II
//这一题类似于小女孩走楼梯的问题，可以是走一步也可以是走两步。
//但是比那个有限制在于，走一步的时候0 是不能走的，走两步的时候只有10-26才能走。
//这时候可以考虑利用DP 来解决问题。
//但实现要解决掉一些特殊情况，比如字符串是空的，返回0 字符串只有一个0 返回0 如果字符串是除了0 之外的其他单个字符返回1.
//在DP 后面设置base case 走到台阶的最后一格的后面可以是两步也可以是1步，但是因为如果1步和两步都放进循环，会超出范围。（当然可以将DP 的空间再增加1）
//然后看最后一个台阶，如果是0 就是表示不能走说明是0 ，其他的情况说明都可以走，而且方法是1
//接下来就是从倒数第二格开始进行倒推，如果是0 说明这格不能走，直接跳过，因为创建数组的时候已经默认是 0
//如果不是0 说明至少可以走1步到下面一个格子，可以把下面一个格子到最后的走的方法复制到前面来。
//如果这个格子和后面一个格子合起来是在10-26之间，说明可以跳两格，这样可以把后面跳两格的方法复制到前面来，再加上默认可以跳一格的方法。
//最终返回的是第一格的统计的方法数

// 但是用dp 的话就要从前往后填，开始要进行判断第一个第二个的情况，要注意的是第二个是在第一个的基础上，如果第二个单独可以，单丝第一个为0 就应该也是不行的。
// 然后后一个如果但是是成立的，就应该在i-1 的基础之上增加，如果两个是成立的，就应该是在i-2的基础上进行增加，
// 开始错误的原因是长度为2的时候直接+1 没有管在第1格中是不是成立。如果不成立，那么在这个格子里面也是不成功的。

public class CheckRestriction {
	public int numDecodings(String s) {
		if (s == null || s.isEmpty()) {
			return 0;
		}

		int len = s.length();
		int[] dp = new int[len];

		if (s.charAt(0) != '0') {
			dp[0] = 1;
		}

		if (len == 1) {
			return dp[0];
		}

		if (s.charAt(1) != '0') {
			dp[1] += dp[0];
		}

		int sum = (s.charAt(0) - '0') * 10 + (s.charAt(1) - '0');
		if (sum >= 10 && sum <= 26) {
			dp[1] += 1;
		}

		for (int i = 2; i < len; i++) {
			if (s.charAt(i) != '0') {
				dp[i] += dp[i - 1];
			}
			sum = (s.charAt(i - 1) - '0') * 10 + (s.charAt(i) - '0');
			if (sum >= 10 && sum <= 26) {
				dp[i] += dp[i - 2];
			}
		}

		return dp[len - 1];
	}
}
